
 // @flow
 import "../constants/types-to-interface-fn.constant.dart" as mapTypeToInterfaceFnName ; import "package:loglevel.dart" as log ; import "../interfaces/rules-engine.types.dart" show EventData , ProgramRule , DataElement , DataElements , ProgramRuleVariable , Constant , OptionSets , Variable ; import "../utils/options.utils.dart" show getoptionSetName ; import "../helpers/rules-engine.helper.dart" show processValue ; const EMPTY_STRING = "" ; const DATAELEMENT_CURRENT_EVENT = "DATAELEMENT_CURRENT_EVENT" ; final Map < String , String > variableSourceTypesDataElementSpecific = { "DATAELEMENT_CURRENT_EVENT" : DATAELEMENT_CURRENT_EVENT } ; final buildVariable = /* Variable */ ( dynamic value , List < dynamic > allValues , String type , bool valueFound , String variablePrefix , [ String variableEventDate , bool useNameForOptionSet ] ) { final processedValues = allValues ? allValues . map ( ( alternateValue ) => processValue ( alternateValue , type ) ) : null ; return { "variableValue" : processValue ( value , type ) , "useCodeForOptionSet" : ! useNameForOptionSet , "variableType" : useNameForOptionSet ? typeKeys . TEXT : type , "hasValue" : valueFound , "variableEventDate" : variableEventDate , "variablePrefix" : variablePrefix , "allValues" : processedValues } ; } ; final getDataElementValueForVariable = ( dynamic value , String dataElementId , [ bool useNameForOptionSet , DataElements dataElements , OptionSets optionSets ] ) { final hasValue = ! ! value || identical ( value , 0 ) || identical ( value , false ) ; return hasValue && useNameForOptionSet && dataElements && dataElements [ dataElementId ] && dataElements [ dataElementId ] . optionSetId ? getoptionSetName ( optionSets [ dataElements [ dataElementId ] . optionSetId ] . options , value ) : value ; } ; final getVariableFromCurrentEvent = /* Variable */ ( ProgramRuleVariable programRuleVariable , DataElements dataElements , Map < String , dynamic > eventData , OptionSets optionSets ) {
 // $FlowFixMe
 final String dataElementId = programRuleVariable . dataElement && programRuleVariable . dataElement . id ; final DataElement dataElement = dataElements [ dataElementId ] ; if ( ! eventData ) { return null ; } final dataElementValue = eventData && eventData [ dataElementId ] ; if ( ! dataElementValue && ! identical ( dataElementValue , 0 ) && ! identical ( dataElementValue , false ) ) { return null ; } final value = getDataElementValueForVariable ( dataElementValue , dataElementId , programRuleVariable . useNameForOptionSet , dataElements , optionSets ) ; return buildVariable ( value , null , dataElement . valueType , true , variablePrefixes . DATAELEMENT , eventData . eventDate , programRuleVariable . useNameForOptionSet ) ; } ; final Map < String , Function > functionMapper = { "DATAELEMENT_CURRENT_EVENT" : getVariableFromCurrentEvent } ; final getVariables = ( EventData eventData , List < ProgramRule > programRules , List < ProgramRuleVariable > programRuleVariables , DataElements dataElements , OptionSets optionSets ) { final variables = programRuleVariables . reduce ( ( [ dynamic accVariables = const { } , ProgramRuleVariable currentRuleVariable ] ) { var variable ; final = currentRuleVariable ; final String variableKey = currentRuleVariable . name ; final getterFunction = functionMapper [ programRuleVariableSourceType ] ; if ( ! getterFunction ) {
 // log.error(

 //   `Unknown programRuleVariableSourceType:${currentRuleVariable.programRuleVariableSourceType}`

 // );
 variable = buildVariable ( EMPTY_STRING , null , typeKeys . TEXT , false , variablePrefixes . DATAELEMENT , null , currentRuleVariable . useNameForOptionSet ) ; accVariables [ variableKey ] = variable ; return accVariables ; } if ( variableSourceTypesDataElementSpecific [ programRuleVariableSourceType ] ) { variable = preCheckDataElement ( currentRuleVariable , dataElements ) ; } if ( variable ) { accVariables [ variableKey ] = variable ; return accVariables ; } variable = getterFunction ( currentRuleVariable , dataElements , eventData . dataValues , optionSets ) ; if ( ! variable ) { variable = postcheckDataElement ( currentRuleVariable , dataElements ) ; } if ( variable ) { accVariables [ variableKey ] = variable ; } return accVariables ; } , { } ) ; return { "variables" : variables , getConstantVariables ( ) ; } ; } ; final preCheckDataElement = ( ProgramRuleVariable programVariable , [ DataElements dataElements ] ) { final dataElementId = programVariable . dataElement && programVariable . dataElement . id ; final dataElement = dataElementId && dataElements && dataElements [ dataElementId ] ; if ( ! dataElement ) {
 // log.warn(

 //   `Variable id:${programVariable.id} name:${

 //     programVariable.displayName

 //   } contains an invalid dataelement id (id: ${dataElementId || ''})`

 // );
 return buildVariable ( EMPTY_STRING , null , typeKeys . TEXT , false , variablePrefixes . DATAELEMENT , null , programVariable . useNameForOptionSet ) ; } return null ; } ; final postcheckDataElement = ( ProgramRuleVariable programVariable , DataElements dataElements ) { final dataElementId = programVariable . dataElement && programVariable . dataElement . id ;
 // $FlowFixMe
 final DataElement dataElement = dataElements [ dataElementId ] ; return buildVariable ( EMPTY_STRING , null , dataElement . valueType , false , variablePrefixes . DATAELEMENT , EMPTY_STRING , programVariable . useNameForOptionSet ) ; } ; final getConstantVariables = ( [ List < Constant > constants ] ) { final constantVariables = constants ? constants . reduce ( ( dynamic accConstantVariables , constant ) { accConstantVariables [ constant . id ] = buildVariable ( constant . value , null , typeKeys . INTEGER , true , variablePrefixes . CONSTANT_VARIABLE , null , false ) ; return accConstantVariables ; } , { } ) : { } ; return constantVariables ; } ;