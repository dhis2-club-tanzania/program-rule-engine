
 // @flow
 import "package:loglevel.dart" as log ; import "rules-engine.helper.dart" show processValue ; final Array< dynamic > d2FuctionsVariables = [ { "name" : "d2:daysBetween" , "parameters" : 2 } , { "name" : "d2:weeksBetween" , "parameters" : 2 } , { "name" : "d2:monthsBetween" , "parameters" : 2 } , { "name" : "d2:yearsBetween" , "parameters" : 2 } , { "name" : "d2:floor" , "parameters" : 1 } , { "name" : "d2:modulus" , "parameters" : 2 } , { "name" : "d2:concatenate" } , { "name" : "d2:addDays" , "parameters" : 2 } , { "name" : "d2:zing" , "parameters" : 1 } , { "name" : "d2:oizp" , "parameters" : 1 } , { "name" : "d2:count" , "parameters" : 1 } , { "name" : "d2:countIfZeroPos" , "parameters" : 1 } , { "name" : "d2:countIfValue" , "parameters" : 2 } , { "name" : "d2:ceil" , "parameters" : 1 } , { "name" : "d2:round" , "parameters" : 1 } , { "name" : "d2:hasValue" , "parameters" : 1 } , { "name" : "d2:lastEventDate" , "parameters" : 1 } , { "name" : "d2:validatePattern" , "parameters" : 2 } , { "name" : "d2:addControlDigits" , "parameters" : 1 } , { "name" : "d2:checkControlDigits" , "parameters" : 1 } , { "name" : "d2:left" , "parameters" : 2 } , { "name" : "d2:right" , "parameters" : 2 } , { "name" : "d2:substring" , "parameters" : 3 } , { "name" : "d2:split" , "parameters" : 3 } , { "name" : "d2:zScoreWFA" , "parameters" : 3 } , { "name" : "d2:length" , "parameters" : 1 } ] ; final Map < String , Function > d2FunctionsEval = { "d2:hasValue" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final variableObject = variableHash [ variableName ] ; var valueFound = false ; if ( variableObject ) { if ( variableObject . hasValue ) { valueFound = true ; } } else { }
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , valueFound ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:daysBetween" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final daysBetween = dateUtils . daysBetween ( date1 , date2 ) ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , daysBetween ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:weeksBetween" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final weeksBetween = dateUtils . weeksBetween ( date1 , date2 ) ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , weeksBetween ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:monthsBetween" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final monthsBetween = dateUtils . monthsBetween ( date1 , date2 ) ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , monthsBetween ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:yearsBetween" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final yearsBetween = dateUtils . yearsBetween ( date1 , date2 ) ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , yearsBetween ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:floor" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final floored = Math . floor ( date1 ) ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , floored ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:modulus" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final rest = Number ( dividend ) % Number ( divisor ) ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , rest ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:concatenate" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { var returnString = "'" ; for ( var i = 0 ; i < parameters . length ; i ++ ) { returnString += parameters [ i ] ; } returnString += "'" ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , returnString ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:addDays" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final newDate = dateUtils . addDays ( date , daysToAdd ) ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , newDate ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:zing" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) { final numBer = parameters [ 0 ] < 0 ? 0 : parameters [ 0 ] ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , numBer ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:oizp" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) { final numBer = parameters [ 0 ] < 0 ? 0 : 1 ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , numBer ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:count" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final = parameters ; final variableObject = variableHash [ variableName ] ; final count = variableObject && variableObject . hasValue && variableObject . allValues ? variableObject . allValues . length : 0 ; if ( ! variableObject ) { }
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , count ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:countIfZeroPos" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final variableName = trimQuotes ( parameters [ 0 ] ) ; final variableObject = variableHash [ variableName ] ; var count = 0 ; if ( variableObject ) { if ( variableObject . hasValue ) { if ( variableObject . allValues && variableObject . allValues . length > 0 ) { for ( var i = 0 ; i < variableObject . allValues . length ; i ++ ) { if ( variableObject . allValues [ i ] >= 0 ) { count ++ ; } } } else {
 //The variable has a value, but no list of alternates. This means we only compare the elements real value
 if ( variableObject . variableValue >= 0 ) { count = 1 ; } } } } else { }
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , count ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:countIfValue" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final variableName = trimQuotes ( parameters [ 0 ] ) ; final variableObject = variableHash [ variableName ] ; final valueToCompare = processValue ( parameters [ 1 ] , variableObject . variableType ) ; var count = 0 ; if ( variableObject ) { if ( variableObject . hasValue ) { if ( variableObject . allValues && variableObject . allValues . length > 0 ) { for ( var i = 0 ; i < variableObject . allValues . length ; i ++ ) { if ( identical ( valueToCompare , variableObject . allValues [ i ] ) ) { count ++ ; } } } else {
 //The variable has a value, but no list of alternates. This means we only compare the elements real value
 if ( variableObject . variableValue >= 0 ) { count = 1 ; } } } } else { }
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , count ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:ceil" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) {
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , Math . ceil ( parameters [ 0 ] ) ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:round" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) {
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , Math . round ( parameters [ 0 ] ) ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:lastEventDate" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final variableName = parameters [ 0 ] ; final variableObject = variableHash [ variableName ] ; var valueFound = "''" ; if ( variableObject ) { if ( variableObject . variableEventDate ) { valueFound = processValue ( variableObject . variableEventDate , "DATE" ) ; } else { } } else { }
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , valueFound ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:validatePattern" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) { final inputToValidate = parameters [ 0 ] . toString ( ) ; final pattern = parameters [ 1 ] ; final regEx = new RegExp ( pattern , "g" ) ; final match = inputToValidate . match ( regEx ) ; final matchFound = ! identical ( match , null ) && identical ( inputToValidate , match [ 0 ] ) ? true : false ;
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , matchFound ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:addControlDigits" : ( dynamic expression , Array< dynamic > parameters , dynamic variableHash , String regexFunct ) { final baseNumber = parameters [ 0 ] ; var newExpression ; final baseDigits = baseNumber . split ( "" ) ; final error = false ; var firstDigit = 0 ; var secondDigit = 0 ; var baseNumberLength = baseDigits && baseDigits . length ; if ( baseDigits && baseDigits . length < 10 ) { var firstSum = 0 ; final baseNumberLength = baseDigits . length ;
 //weights support up to 9 base digits:
 final firstWeights = [ 3 , 7 , 6 , 1 , 8 , 9 , 4 , 5 , 2 ] ; for ( var i = 0 ; i < baseNumberLength && ! error ; i ++ ) { firstSum += parseInt ( baseDigits [ i ] ) * firstWeights [ i ] ; } firstDigit = firstSum % 11 ;
 //Push the first digit to the array before continuing, as the second digit is a result of the

 //base digits and the first control digit.
 baseDigits . push ( firstDigit ) ;
 //Weights support up to 9 base digits plus first control digit:
 var secondWeights = [ 5 , 4 , 3 , 2 , 7 , 6 , 5 , 4 , 3 , 2 ] ; var secondSum = 0 ; for ( var i = 0 ; i < baseNumberLength + 1 && ! error ; i ++ ) { secondSum += parseInt ( baseDigits [ i ] ) * secondWeights [ i ] ; } secondDigit = secondSum % 11 ; if ( identical ( firstDigit , 10 ) ) {
 // log.warn('First control digit became 10, replacing with 0');
 firstDigit = 0 ; } if ( identical ( secondDigit , 10 ) ) {
 // log.warn('Second control digit became 10, replacing with 0');
 secondDigit = 0 ; } } else { } if ( ! error ) {
 //Replace the end evaluation of the dhis function:
 newExpression = expression . replace ( regexFunct , baseNumber + firstDigit + secondDigit ) ; } else {
 //Replace the end evaluation of the dhis function:
 newExpression = expression . replace ( regexFunct , baseNumber ) ; } final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:checkControlDigits" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) {
 // log.warn('checkControlDigits not implemented yet');

 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , parameters [ 0 ] ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:left" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) { final string = String ( parameters [ 0 ] ) ; final numChars = string . length < parameters [ 1 ] ? string . length : parameters [ 1 ] ; var returnString = string . substring ( 0 , numChars ) ; returnString = processValue ( returnString , "TEXT" ) ; final newExpression = expression . replace ( regexFunct , returnString ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:right" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) { final string = String ( parameters [ 0 ] ) ; final numChars = string . length < parameters [ 1 ] ? string . length : parameters [ 1 ] ; var returnString = string . substring ( string . length - numChars , string . length ) ; returnString = processValue ( returnString , "TEXT" ) ; final newExpression = expression . replace ( regexFunct , returnString ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:substring" : ( dynamic expression , Array< num > parameters , dynamic variableHash , String regexFunct ) { final string = String ( parameters [ 0 ] ) ; final startChar = string . length < parameters [ 1 ] - 1 ? - 1 : parameters [ 1 ] ; final endChar = string . length < parameters [ 2 ] ? - 1 : parameters [ 2 ] ; var newExpression ; final expressionUpdated = true ; if ( startChar < 0 || endChar < 0 ) { expression = expression . replace ( regexFunct , "''" ) ; } else { final returnString = processValue ( string . substring ( startChar , endChar ) , "TEXT" ) ; expression = expression . replace ( regexFunct , returnString ) ; } return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:split" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) {
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , String ( parameters [ 0 ] ) . length ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:zScoreWFA" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) {
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , getZScoreWFA ( parseFloat ( parameters [ 0 ] ) , parseFloat ( parameters [ 1 ] ) , parameters [ 2 ] ) ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } , "d2:length" : ( dynamic expression , Array< String > parameters , dynamic variableHash , String regexFunct ) {
 //Replace the end evaluation of the dhis function:
 final newExpression = expression . replace ( regexFunct , String ( parameters [ 0 ] ) . length ) ; final expressionUpdated = true ; return { "expression" : newExpression , "expressionUpdated" : expressionUpdated } ; } } ;